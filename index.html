<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Comédie Française Registers Project</title>
  <style>
    body {
      font: 14px sans-serif;
    }
    svg {
      clear: none;
      font: 10px sans-serif;
    }
    .sidebar { 
      float: right; 
      clear: none; 
      margin: 10px;
      width: 300px;
    }
    .viz {
      cursor: pointer;
    }
    .viz:not(:hover) .close {
      display:none;
    }

    .viz .background {
      opacity: 0;
    }

    /* component-specific css: figure out an export solution for svg */
    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .line {
      fill: none;
      stroke: orange;
      stroke-width: 1.5px;
    }
  </style>
  <script src="lib/d3.min.js"></script>
  <script src="lib/crossfilter.min.js"></script>
  <script src="lib/queue.min.js"></script>
  <script src="join.js"></script>
  <script src="mdat.js"></script>
  <script src="genre_chord.js"></script>
  <script src="receipts_by_author.js"></script>
  <script src="receipts_timeseries.js"></script>
</head>
<body>
  <script>

    var dateFormat = d3.time.format("%Y-%m-%d");

    queue()
      .defer(d3.tsv, "data/cfrp-sales.tsv")
      .defer(d3.tsv, "data/cfrp-performances.tsv")
      .defer(d3.tsv, "data/cfrp-plays.tsv")
      .await(function(error, sales, performances, plays) {
        if (error) return console.error(error);

        // TODO.  decide whether to denormalize the data entirely...
        //        this embeds the join between sales and playbill in
        //        a hash dereference

        var playbill = join_hash(performances, plays, ["author", "title"]),
            playbill_idx = {};

        playbill = playbill.map(function(d) {
          d.date = dateFormat.parse(d.date);
          d.prologue = (d.prologue === 't');
          d.musique_danse_machine = (d.musique_danse_machine === 't');
          d.ordering = +d.ordering;
          d.register = +d.register;
          d.receipts = +d.receipts;
          d.representation = +d.representation;
          d.ouverture = (d.ouverture === 't');
          d.cloture = (d.cloture === 't');
          d.free_access = (d.free_access === 't');
          d.firstrun = (d.firstrun === 't');
          d.firstrun_perfnum = +d.firstrun_perfnum;
          d.reprise = (d.reprise === 't');
          d.reprise_perfnum = +d.reprise_perfnum;
          d.debut = (d.debut === 't');
          d.acts = +d.acts;
          return d;
        });

        playbill.forEach(function(d) {
          if (!playbill_idx[d.date]) { playbill_idx[d.date] = []; }
          playbill_idx[d.date].push(d);
        });

        sales = sales.map(function(d) {
          d.date = dateFormat.parse(d.date);
          d.sold = +d.sold;
          d.price = +d.price;
          return d;
        });

        // index relevant columns

        cfrp = crossfilter(sales);

        // TODO. how to share ancillary data?
        cfrp.sales = sales;
        cfrp.playbill = playbill;
        cfrp.playbill_idx = playbill_idx;

        // TODO. best way to share dimensions across visualizations?
        cfrp.date = cfrp.dimension(function(d) { return d.date; });
        cfrp.receipts = cfrp.dimension(function(d) { return d.price * d.sold; });
        cfrp.section = cfrp.dimension(function(d) { return d.section; });

        var mplex = mdat.mplex()
          .datapoint(cfrp);

        d3.select("body").call(mplex);
      });
  </script>
</body>
</html>